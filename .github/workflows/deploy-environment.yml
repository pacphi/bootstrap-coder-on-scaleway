name: Deploy Coder Environment

# Set minimal required permissions for security
permissions:
  contents: read        # Access repository code
  issues: write        # Create deployment failure issues
  pull-requests: write # Comment on PRs with deployment status
  actions: read        # Download/upload artifacts
  id-token: write      # For OIDC authentication if needed

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      template:
        description: 'Workspace template to deploy (leave empty to skip)'
        required: false
        type: string
      domain_name:
        description: 'Domain name for SSL certificates (leave empty for IP-based access)'
        required: false
        type: string
      subdomain:
        description: 'Subdomain prefix (defaults: dev=coder-dev, staging=coder-staging, prod=coder)'
        required: false
        type: string
      enable_monitoring:
        description: 'Enable monitoring stack'
        required: false
        type: boolean
        default: false
      auto_approve:
        description: 'Auto-approve deployment without confirmation'
        required: false
        type: boolean
        default: false
      dry_run:
        description: 'Preview changes without applying'
        required: false
        type: boolean
        default: false

  # Allow manual PR triggers for staging deployments
  pull_request:
    types: [opened, synchronize, labeled]
    paths:
      - 'environments/**'
      - 'modules/**'
      - 'templates/**'
      - 'scripts/**'

  # Auto-deploy on push to main for staging
  push:
    branches: [main]
    paths:
      - 'environments/staging/**'
      - 'modules/**'

env:
  TF_IN_AUTOMATION: true
  TF_VAR_scaleway_region: ${{ vars.SCALEWAY_REGION || 'fr-par' }}
  TF_VAR_scaleway_zone: ${{ vars.SCALEWAY_ZONE || 'fr-par-1' }}

jobs:
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      deploy_env: ${{ steps.determine-env.outputs.environment }}
      deploy_template: ${{ steps.determine-env.outputs.template }}
      deploy_domain: ${{ steps.determine-env.outputs.domain_name }}
      deploy_subdomain: ${{ steps.determine-env.outputs.subdomain }}
      enable_monitoring: ${{ steps.determine-env.outputs.enable_monitoring }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Determine Deployment Environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "template=${{ github.event.inputs.template }}" >> $GITHUB_OUTPUT
            echo "domain_name=${{ github.event.inputs.domain_name }}" >> $GITHUB_OUTPUT
            echo "subdomain=${{ github.event.inputs.subdomain }}" >> $GITHUB_OUTPUT
            echo "enable_monitoring=${{ github.event.inputs.enable_monitoring }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            if [[ "${{ contains(github.event.pull_request.labels.*.name, 'deploy-staging') }}" == "true" ]]; then
              echo "environment=staging" >> $GITHUB_OUTPUT
              echo "template=" >> $GITHUB_OUTPUT
              echo "domain_name=" >> $GITHUB_OUTPUT
              echo "subdomain=" >> $GITHUB_OUTPUT
              echo "enable_monitoring=false" >> $GITHUB_OUTPUT
            else
              echo "Skip deployment for this PR"
              exit 0
            fi
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "template=" >> $GITHUB_OUTPUT
            echo "domain_name=" >> $GITHUB_OUTPUT
            echo "subdomain=" >> $GITHUB_OUTPUT
            echo "enable_monitoring=true" >> $GITHUB_OUTPUT
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.6.0"

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.12.0'

      - name: Configure Scaleway Credentials for Validation
        env:
          SCW_ACCESS_KEY: ${{ secrets.SCW_ACCESS_KEY }}
          SCW_SECRET_KEY: ${{ secrets.SCW_SECRET_KEY }}
          SCW_DEFAULT_PROJECT_ID: ${{ secrets.SCW_DEFAULT_PROJECT_ID }}
          SCW_DEFAULT_ORGANIZATION_ID: ${{ secrets.SCW_DEFAULT_ORGANIZATION_ID }}
        run: |
          echo "SCW_ACCESS_KEY=${SCW_ACCESS_KEY}" >> $GITHUB_ENV
          echo "SCW_SECRET_KEY=${SCW_SECRET_KEY}" >> $GITHUB_ENV
          echo "SCW_DEFAULT_PROJECT_ID=${SCW_DEFAULT_PROJECT_ID}" >> $GITHUB_ENV
          echo "SCW_DEFAULT_ORGANIZATION_ID=${SCW_DEFAULT_ORGANIZATION_ID}" >> $GITHUB_ENV

      - name: Validate Terraform Configuration
        run: |
          cd environments/${{ steps.determine-env.outputs.environment }}
          terraform fmt -check -recursive

          # Initialize with remote backend if backend.tf exists, otherwise use local backend
          if [[ -f "backend.tf" ]]; then
            echo "üîÑ Initializing with remote backend..."
            terraform init
          else
            echo "‚ö†Ô∏è No remote backend configured, using local backend for validation"
            terraform init -backend=false
          fi

          terraform validate

      - name: Validate Template (if specified)
        if: ${{ steps.determine-env.outputs.template != '' }}
        run: |
          # Find and validate template
          template_path=""
          while IFS= read -r -d '' template_file; do
            template_name=$(dirname "$template_file" | sed 's|.*/templates/.*/||')
            if [[ "$template_name" == "${{ steps.determine-env.outputs.template }}" ]]; then
              template_path=$(dirname "$template_file")
              break
            fi
          done < <(find ./templates -name "main.tf" -type f -print0)

          if [[ -z "$template_path" ]]; then
            echo "::error::Template not found: ${{ steps.determine-env.outputs.template }}"
            exit 1
          fi

          cd "$template_path"
          terraform init -backend=false
          terraform validate
          echo "::notice::Template validated: ${{ steps.determine-env.outputs.template }}"

  setup-backend:
    name: Setup Terraform Backend
    needs: validate
    if: needs.validate.outputs.deploy_env != ''
    uses: ./.github/workflows/setup-backend.yml
    with:
      environment: ${{ needs.validate.outputs.deploy_env }}
      region: ${{ vars.SCALEWAY_REGION || 'fr-par' }}
      force_recreate: false
    secrets: inherit

  estimate-costs:
    name: Estimate Costs
    runs-on: ubuntu-latest
    needs: [validate, setup-backend]
    if: needs.validate.outputs.deploy_env != '' && needs.setup-backend.outputs.backend_configured == 'true'
    permissions:
      contents: read        # Read repository code
      pull-requests: write  # Comment cost estimates on PRs

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Calculate Cost Estimate
        id: cost-estimate
        run: |
          environment="${{ needs.validate.outputs.deploy_env }}"

          # Cost estimation based on environment
          case "$environment" in
            dev)
              monthly_cost="53.70"
              description="2√óGP1-XS nodes, DB-DEV-S, Basic LB"
              ;;
            staging)
              monthly_cost="97.85"
              description="3√óGP1-S nodes, DB-GP-S, Basic LB"
              ;;
            prod)
              monthly_cost="374.50"
              description="5√óGP1-M nodes, DB-GP-M HA, Enhanced LB"
              ;;
          esac

          echo "monthly_cost=$monthly_cost" >> $GITHUB_OUTPUT
          echo "description=$description" >> $GITHUB_OUTPUT
          echo "environment=$environment" >> $GITHUB_OUTPUT

      - name: Comment Cost Estimate on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const { monthly_cost, description, environment } = ${{ steps.cost-estimate.outputs }};

            const body = `## üí∞ Cost Impact Analysis

            **Environment:** \`${environment}\`
            **Estimated Monthly Cost:** ‚Ç¨${monthly_cost}
            **Resources:** ${description}

            > This is an estimate based on Scaleway pricing. Actual costs may vary.

            **Template:** ${{ needs.validate.outputs.deploy_template || 'None specified' }}
            **Monitoring:** ${{ needs.validate.outputs.enable_monitoring }}`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  plan:
    name: Plan Infrastructure Changes
    runs-on: ubuntu-latest
    needs: [validate, setup-backend, estimate-costs]
    if: needs.validate.outputs.deploy_env != '' && needs.setup-backend.outputs.backend_configured == 'true'
    permissions:
      contents: read        # Read repository code
      pull-requests: write  # Comment plan results on PRs
    outputs:
      plan_id: ${{ steps.plan.outputs.plan_id }}
      has_changes: ${{ steps.plan.outputs.has_changes }}
      plan_summary: ${{ steps.plan.outputs.plan_summary }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.6.0"
          terraform_wrapper: false

      - name: Configure Scaleway Credentials
        env:
          SCW_ACCESS_KEY: ${{ secrets.SCW_ACCESS_KEY }}
          SCW_SECRET_KEY: ${{ secrets.SCW_SECRET_KEY }}
          SCW_DEFAULT_PROJECT_ID: ${{ secrets.SCW_DEFAULT_PROJECT_ID }}
          SCW_DEFAULT_ORGANIZATION_ID: ${{ secrets.SCW_DEFAULT_ORGANIZATION_ID }}
        run: |
          echo "SCW_ACCESS_KEY=${SCW_ACCESS_KEY}" >> $GITHUB_ENV
          echo "SCW_SECRET_KEY=${SCW_SECRET_KEY}" >> $GITHUB_ENV
          echo "SCW_DEFAULT_PROJECT_ID=${SCW_DEFAULT_PROJECT_ID}" >> $GITHUB_ENV
          echo "SCW_DEFAULT_ORGANIZATION_ID=${SCW_DEFAULT_ORGANIZATION_ID}" >> $GITHUB_ENV

      - name: Download Backend Configuration
        uses: actions/download-artifact@v4
        with:
          name: backend-config-${{ needs.validate.outputs.deploy_env }}-${{ github.run_id }}
          path: ./

      - name: Initialize Terraform Backend
        run: |
          cd environments/${{ needs.validate.outputs.deploy_env }}

          echo "üîÑ Initializing with remote backend..."
          echo "Backend bucket: ${{ needs.setup-backend.outputs.bucket_name }}"
          terraform init

      - name: Plan Infrastructure Changes
        id: plan
        run: |
          cd environments/${{ needs.validate.outputs.deploy_env }}

          # Generate unique plan ID
          plan_id="plan-$(date +%Y%m%d-%H%M%S)-${{ github.run_id }}"
          echo "plan_id=$plan_id" >> $GITHUB_OUTPUT

          # Run terraform plan
          set +e
          terraform plan -detailed-exitcode -out="${plan_id}.tfplan" > plan_output.txt 2>&1
          plan_exit_code=$?
          set -e

          # Parse plan results
          case $plan_exit_code in
            0)
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "plan_summary=No changes needed" >> $GITHUB_OUTPUT
              ;;
            1)
              echo "‚ùå Terraform plan failed"
              cat plan_output.txt
              exit 1
              ;;
            2)
              echo "has_changes=true" >> $GITHUB_OUTPUT

              # Extract plan summary
              if grep -q "Plan:" plan_output.txt; then
                plan_summary=$(grep "Plan:" plan_output.txt | head -1)
                echo "plan_summary=$plan_summary" >> $GITHUB_OUTPUT
              else
                echo "plan_summary=Infrastructure changes detected" >> $GITHUB_OUTPUT
              fi
              ;;
          esac

          # Save plan output for artifacts
          cp plan_output.txt "terraform-plan-${plan_id}.txt"

      - name: Upload Plan Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ needs.validate.outputs.deploy_env }}-${{ github.run_id }}
          path: |
            environments/${{ needs.validate.outputs.deploy_env }}/*.tfplan
            environments/${{ needs.validate.outputs.deploy_env }}/terraform-plan-*.txt
          retention-days: 30

      - name: Comment Plan Results on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const planFile = `environments/${{ needs.validate.outputs.deploy_env }}/terraform-plan-${{ steps.plan.outputs.plan_id }}.txt`;
            let planOutput = '';

            try {
              planOutput = fs.readFileSync(planFile, 'utf8');
            } catch (error) {
              planOutput = 'Plan output not available';
            }

            const body = `## üìã Terraform Plan Results

            **Environment:** \`${{ needs.validate.outputs.deploy_env }}\`
            **Plan ID:** \`${{ steps.plan.outputs.plan_id }}\`
            **Has Changes:** ${{ steps.plan.outputs.has_changes }}
            **Summary:** ${{ steps.plan.outputs.plan_summary }}

            <details>
            <summary>View Plan Details</summary>

            \`\`\`terraform
            ${planOutput.slice(0, 32000)} ${planOutput.length > 32000 ? '... (truncated)' : ''}
            \`\`\`

            </details>

            ${steps.plan.outputs.has_changes === 'true' ? '‚ö†Ô∏è **Review the changes carefully before approving deployment**' : '‚úÖ **No infrastructure changes needed**'}`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  deploy:
    name: Deploy Environment
    runs-on: ubuntu-latest
    needs: [validate, setup-backend, estimate-costs, plan]
    if: needs.validate.outputs.deploy_env != '' && needs.setup-backend.outputs.backend_configured == 'true' && (github.event.inputs.dry_run != 'true' || github.event.inputs.dry_run == '')
    environment:
      name: ${{ needs.validate.outputs.deploy_env }}
      url: ${{ steps.deploy.outputs.coder_url }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.6.0"
          terraform_wrapper: false

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.12.0'

      - name: Configure Scaleway Credentials
        env:
          SCW_ACCESS_KEY: ${{ secrets.SCW_ACCESS_KEY }}
          SCW_SECRET_KEY: ${{ secrets.SCW_SECRET_KEY }}
          SCW_DEFAULT_PROJECT_ID: ${{ secrets.SCW_DEFAULT_PROJECT_ID }}
          SCW_DEFAULT_ORGANIZATION_ID: ${{ secrets.SCW_DEFAULT_ORGANIZATION_ID }}
        run: |
          echo "SCW_ACCESS_KEY=${SCW_ACCESS_KEY}" >> $GITHUB_ENV
          echo "SCW_SECRET_KEY=${SCW_SECRET_KEY}" >> $GITHUB_ENV
          echo "SCW_DEFAULT_PROJECT_ID=${SCW_DEFAULT_PROJECT_ID}" >> $GITHUB_ENV
          echo "SCW_DEFAULT_ORGANIZATION_ID=${SCW_DEFAULT_ORGANIZATION_ID}" >> $GITHUB_ENV

      - name: Setup Deployment Flags
        id: setup-flags
        run: |
          flags="--env=${{ needs.validate.outputs.deploy_env }}"

          if [[ "${{ needs.validate.outputs.deploy_template }}" != "" ]]; then
            flags="$flags --template=${{ needs.validate.outputs.deploy_template }}"
          fi

          if [[ "${{ needs.validate.outputs.deploy_domain }}" != "" ]]; then
            flags="$flags --domain=${{ needs.validate.outputs.deploy_domain }}"
          fi

          if [[ "${{ needs.validate.outputs.deploy_subdomain }}" != "" ]]; then
            flags="$flags --subdomain=${{ needs.validate.outputs.deploy_subdomain }}"
          fi

          if [[ "${{ needs.validate.outputs.enable_monitoring }}" == "true" ]]; then
            flags="$flags --enable-monitoring"
          fi

          if [[ "${{ github.event.inputs.dry_run }}" == "true" ]]; then
            flags="$flags --dry-run"
          else
            flags="$flags --auto-approve"
          fi

          echo "deployment_flags=$flags" >> $GITHUB_OUTPUT

      - name: Download Plan Artifacts
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-${{ needs.validate.outputs.deploy_env }}-${{ github.run_id }}
          path: environments/${{ needs.validate.outputs.deploy_env }}/

      - name: Download Backend Configuration
        uses: actions/download-artifact@v4
        with:
          name: backend-config-${{ needs.validate.outputs.deploy_env }}-${{ github.run_id }}
          path: ./

      - name: Initialize Terraform Backend
        run: |
          cd environments/${{ needs.validate.outputs.deploy_env }}

          echo "üîÑ Initializing with remote backend..."
          echo "Backend bucket: ${{ needs.setup-backend.outputs.bucket_name }}"
          terraform init

      - name: Apply Infrastructure Changes
        id: apply
        run: |
          cd environments/${{ needs.validate.outputs.deploy_env }}

          # Find the plan file
          plan_file=$(ls *.tfplan 2>/dev/null | head -1 || echo "")

          if [[ -n "$plan_file" ]] && [[ -f "$plan_file" ]]; then
            echo "üìã Applying planned changes from: $plan_file"
            terraform apply -auto-approve "$plan_file"
          else
            echo "‚ö†Ô∏è No plan file found, running direct apply"
            if [[ "${{ github.event.inputs.auto_approve }}" == "true" ]]; then
              terraform apply -auto-approve
            else
              terraform apply
            fi
          fi

          echo "apply_completed=true" >> $GITHUB_OUTPUT

      - name: Extract Deployment Outputs
        id: deploy
        if: steps.apply.outputs.apply_completed == 'true'
        run: |
          cd environments/${{ needs.validate.outputs.deploy_env }}

          # Extract outputs
          coder_url=$(terraform output -raw access_url 2>/dev/null || terraform output -raw coder_url 2>/dev/null || echo "")
          admin_username=$(terraform output -raw admin_username 2>/dev/null || echo "admin")
          load_balancer_ip=$(terraform output -raw load_balancer_ip 2>/dev/null || echo "")

          echo "coder_url=$coder_url" >> $GITHUB_OUTPUT
          echo "admin_username=$admin_username" >> $GITHUB_OUTPUT
          echo "load_balancer_ip=$load_balancer_ip" >> $GITHUB_OUTPUT

          # Generate DNS instructions if domain is configured
          if [[ "${{ needs.validate.outputs.deploy_domain }}" != "" ]]; then
            subdomain="${{ needs.validate.outputs.deploy_subdomain }}"
            if [[ -z "$subdomain" ]]; then
              case "${{ needs.validate.outputs.deploy_env }}" in
                dev) subdomain="coder-dev" ;;
                staging) subdomain="coder-staging" ;;
                prod) subdomain="coder" ;;
              esac
            fi
            full_domain="${subdomain}.${{ needs.validate.outputs.deploy_domain }}"

            echo "full_domain=$full_domain" >> $GITHUB_OUTPUT
            echo "dns_required=true" >> $GITHUB_OUTPUT
          else
            echo "dns_required=false" >> $GITHUB_OUTPUT
          fi

          # Save kubeconfig as artifact
          if [[ -f "${HOME}/.kube/config-coder-${{ needs.validate.outputs.deploy_env }}" ]]; then
            cp "${HOME}/.kube/config-coder-${{ needs.validate.outputs.deploy_env }}" ./kubeconfig-${{ needs.validate.outputs.deploy_env }}
          fi

      - name: Upload Kubeconfig Artifact
        if: steps.apply.outputs.apply_completed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig-${{ needs.validate.outputs.deploy_env }}
          path: environments/${{ needs.validate.outputs.deploy_env }}/kubeconfig-${{ needs.validate.outputs.deploy_env }}
          retention-days: 7

      - name: Validate Deployment
        if: steps.apply.outputs.apply_completed == 'true'
        run: |
          chmod +x scripts/validate.sh
          ./scripts/validate.sh --env=${{ needs.validate.outputs.deploy_env }} --quick

      - name: Comment Deployment Success on PR
        if: github.event_name == 'pull_request' && steps.apply.outputs.apply_completed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            let body = `## ‚úÖ Deployment Successful

            **Environment:** \`${{ needs.validate.outputs.deploy_env }}\`
            **Template:** ${{ needs.validate.outputs.deploy_template || 'None' }}
            **Coder URL:** ${{ steps.deploy.outputs.coder_url }}
            **Admin Username:** ${{ steps.deploy.outputs.admin_username }}
            **Load Balancer IP:** ${{ steps.deploy.outputs.load_balancer_ip }}`;

            // Add DNS configuration if domain is configured
            if ('${{ steps.deploy.outputs.dns_required }}' === 'true') {
              body += `

            ## üåê DNS Configuration Required

            **Domain:** ${{ steps.deploy.outputs.full_domain }}

            Configure these DNS records at your domain registrar:

            **A Record:**
            - Name: \`${{ steps.deploy.outputs.full_domain }}\`
            - Value: \`${{ steps.deploy.outputs.load_balancer_ip }}\`
            - TTL: \`300\`

            **CNAME Record (Wildcard):**
            - Name: \`*.${{ steps.deploy.outputs.full_domain }}\`
            - Value: \`${{ steps.deploy.outputs.full_domain }}\`
            - TTL: \`300\`

            After DNS propagation (5-15 minutes):
            - SSL certificates will be issued automatically
            - Access Coder at: https://${{ steps.deploy.outputs.full_domain }}
            - Workspaces will use: https://*.${{ steps.deploy.outputs.full_domain }}`;
            } else {
              body += `

            ‚ö†Ô∏è **IP-Based Access:** This deployment uses IP-based access. Users will see browser warnings for self-signed certificates.`;
            }

            body += `

            üéâ Your Coder environment is ready to use!`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      - name: Update Deployment Status
        if: always()
        run: |
          if [[ "${{ job.status }}" == "success" && "${{ steps.apply.outputs.apply_completed }}" == "true" ]]; then
            echo "‚úÖ Deployment completed successfully!"
            echo "Environment: ${{ needs.validate.outputs.deploy_env }}"
            echo "Coder URL: ${{ steps.deploy.outputs.coder_url }}"
            echo "Plan Summary: ${{ needs.plan.outputs.plan_summary }}"
          elif [[ "${{ job.status }}" == "success" && "${{ needs.plan.outputs.has_changes }}" == "false" ]]; then
            echo "‚úÖ No changes were needed!"
            echo "Environment: ${{ needs.validate.outputs.deploy_env }}"
            echo "Infrastructure is up to date."
          else
            echo "‚ùå Deployment failed!"
            exit 1
          fi

  notify:
    name: Notify Teams
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    if: always() && needs.validate.outputs.deploy_env != ''
    permissions:
      contents: read  # Read repository information
      issues: write   # Create issues on deployment failure

    steps:
      - name: Notify Slack (if configured)
        if: vars.SLACK_WEBHOOK_URL
        env:
          SLACK_WEBHOOK_URL: ${{ vars.SLACK_WEBHOOK_URL }}
        run: |
          status="${{ needs.deploy.result }}"
          environment="${{ needs.validate.outputs.deploy_env }}"

          if [[ "$status" == "success" ]]; then
            color="good"
            emoji="‚úÖ"
            text="Coder environment deployment succeeded"
          else
            color="danger"
            emoji="‚ùå"
            text="Coder environment deployment failed"
          fi

          payload="{
            \"attachments\": [{
              \"color\": \"$color\",
              \"text\": \"$emoji $text\",
              \"fields\": [
                {\"title\": \"Environment\", \"value\": \"$environment\", \"short\": true},
                {\"title\": \"Template\", \"value\": \"${{ needs.validate.outputs.deploy_template || 'None' }}\", \"short\": true},
                {\"title\": \"Triggered by\", \"value\": \"${{ github.actor }}\", \"short\": true},
                {\"title\": \"Repository\", \"value\": \"${{ github.repository }}\", \"short\": true}
              ]
            }]
          }"

          curl -X POST -H 'Content-type: application/json' \
            --data "$payload" "$SLACK_WEBHOOK_URL"

      - name: Create GitHub Issue on Failure
        if: needs.deploy.result == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `Deployment Failed: ${{ needs.validate.outputs.deploy_env }} environment`;
            const body = `## Deployment Failure Report

            **Environment:** ${{ needs.validate.outputs.deploy_env }}
            **Template:** ${{ needs.validate.outputs.deploy_template || 'None' }}
            **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            **Triggered by:** ${{ github.actor }}
            **Commit:** ${{ github.sha }}

            The automated deployment has failed. Please check the workflow logs for details.

            ## Next Steps
            1. Review the workflow logs
            2. Check Scaleway console for any resources that need cleanup
            3. Verify Scaleway credentials and quotas
            4. Re-run the deployment after fixing issues

            **Labels:** deployment-failure, ${{ needs.validate.outputs.deploy_env }}`;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['deployment-failure', '${{ needs.validate.outputs.deploy_env }}']
            });