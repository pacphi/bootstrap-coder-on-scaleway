name: Deploy Infrastructure (Phase 1)

# Set minimal required permissions for security
permissions:
  contents: read       # Access repository code
  issues: write        # Create deployment failure issues
  pull-requests: write # Comment on PRs with deployment status
  actions: read        # Download/upload artifacts
  id-token: write      # For OIDC authentication if needed

on:
  workflow_dispatch:
    inputs:
      bucket_name:
        description: 'Name of the bucket in object store that will hold Terraform state'
        required: false
        type: string
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      region:
        description: 'Scaleway region'
        required: true
        type: choice
        options:
          - fr-par
          - nl-ams
          - pl-waw
        default: 'fr-par'
      availability_zone:
        description: 'Scaleway availibility zone (which should be within region)'
        required: true
        type: choice
        options:
          - fr-par-1
          - fr-par-2
          - fr-par-3
          - nl-ams-1
          - nl-ams-2
          - nl-ams-3
          - pl-waw-1
          - pl-waw-2
          - pl-waw-3
        default: 'fr-par-1'
      domain_name:
        description: 'Domain name for SSL certificates (leave empty for IP-based access)'
        required: false
        type: string
      subdomain:
        description: 'Subdomain prefix (defaults: dev=coder-dev, staging=coder-staging, prod=coder)'
        required: false
        type: string
      auto_approve:
        description: 'Auto-approve deployment without confirmation'
        required: false
        type: boolean
        default: false
      dry_run:
        description: 'Preview changes without applying'
        required: false
        type: boolean
        default: false

  workflow_call:
    inputs:
      bucket_name:
        description: 'Name of the bucket in object store that will hold Terraform state'
        required: false
        type: string
      environment:
        description: 'Target environment'
        required: true
        type: string
      region:
        description: 'Scaleway region'
        required: true
        type: string
      availability_zone:
        description: 'Scaleway availibility zone'
        required: true
        type: string
      domain_name:
        description: 'Domain name for SSL certificates'
        required: false
        type: string
      subdomain:
        description: 'Subdomain prefix'
        required: false
        type: string
      auto_approve:
        description: 'Auto-approve deployment without confirmation'
        required: false
        type: boolean
        default: false
      dry_run:
        description: 'Preview changes without applying'
        required: false
        type: boolean
        default: false
    secrets:
      SCW_ACCESS_KEY:
        required: true
      SCW_SECRET_KEY:
        required: true
      SCW_DEFAULT_PROJECT_ID:
        required: true
      SCW_DEFAULT_ORGANIZATION_ID:
        required: true

env:
  TF_IN_AUTOMATION: true
  TF_VAR_scaleway_region: ${{ inputs.region }}
  TF_VAR_scaleway_zone: ${{ inputs.availability_zone }}
  # Consolidated Scaleway credentials and mappings
  SCW_ACCESS_KEY: ${{ secrets.SCW_ACCESS_KEY }}
  SCW_SECRET_KEY: ${{ secrets.SCW_SECRET_KEY }}
  SCW_DEFAULT_PROJECT_ID: ${{ secrets.SCW_DEFAULT_PROJECT_ID }}
  SCW_DEFAULT_ORGANIZATION_ID: ${{ secrets.SCW_DEFAULT_ORGANIZATION_ID }}
  # AWS variables for S3 backend compatibility
  AWS_ACCESS_KEY_ID: ${{ secrets.SCW_ACCESS_KEY }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.SCW_SECRET_KEY }}

jobs:
  validate:
    name: Validate Infrastructure Configuration
    runs-on: ubuntu-latest
    outputs:
      deploy_env: ${{ steps.determine-env.outputs.environment }}
      deploy_domain: ${{ steps.determine-env.outputs.domain_name }}
      deploy_subdomain: ${{ steps.determine-env.outputs.subdomain }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Determine Deployment Environment
        id: determine-env
        run: |
          echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          echo "domain_name=${{ inputs.domain_name }}" >> $GITHUB_OUTPUT
          echo "subdomain=${{ inputs.subdomain }}" >> $GITHUB_OUTPUT

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.12.0"

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.32.0'

      - name: Check Terraform Formatting (Infrastructure)
        run: |
          echo "🔍 Checking Terraform formatting for infrastructure..."

          format_issues=()
          env_dir="environments/${{ inputs.environment }}/infra"

          if [[ -d "$env_dir" ]]; then
            echo "📁 Checking infrastructure: $env_dir"
            cd "$env_dir"

            if ! terraform fmt -check -diff .; then
              format_issues+=("Infrastructure: $env_dir")
            fi
            cd - > /dev/null
          else
            echo "❌ Infrastructure directory not found: $env_dir"
            exit 1
          fi

          # Check modules
          for module_dir in modules/*/; do
            if [[ -d "$module_dir" ]]; then
              echo "📦 Checking module: $(basename "$module_dir")"
              cd "$module_dir"

              if ! terraform fmt -check -diff .; then
                format_issues+=("Module: $(basename "$module_dir")")
              fi
              cd - > /dev/null
            fi
          done

          # Report format issues
          if [[ ${#format_issues[@]} -gt 0 ]]; then
            echo "❌ Terraform formatting issues found in the following locations:"
            for issue in "${format_issues[@]}"; do
              echo "  - $issue"
            done
            echo ""
            echo "💡 To fix formatting issues, run the following commands locally:"
            echo "   terraform fmt -recursive ."
            echo "   git add -A && git commit -m 'Fix Terraform formatting'"
            echo ""
            echo "🚫 Workflow will continue, but formatting should be fixed in the next commit."
          else
            echo "✅ All Terraform files are properly formatted"
          fi

      - name: Validate Infrastructure Configuration
        run: |
          environment="${{ inputs.environment }}"
          env_dir="environments/$environment/infra"

          echo "🔍 Validating infrastructure configuration for environment: $environment"

          # Check if infrastructure directory exists
          if [[ ! -d "$env_dir" ]]; then
            echo "❌ Infrastructure directory not found: $env_dir"
            echo "Available environments:"
            ls -la environments/
            exit 1
          fi

          cd "$env_dir"

          # Validate configuration files exist
          if [[ ! -f "main.tf" ]]; then
            echo "❌ main.tf not found in $env_dir"
            ls -la .
            exit 1
          fi

          echo "📄 Found configuration files:"
          ls -la *.tf 2>/dev/null || echo "No .tf files found"

          # Initialize with remote backend if backend.tf exists, otherwise use local backend
          if [[ -f "backend.tf" ]]; then
            echo "🔄 Initializing with remote backend..."
            if ! terraform init 2>&1; then
              echo "❌ Terraform initialization failed with remote backend"
              exit 1
            fi
          else
            echo "⚠️ No remote backend configured, using local backend for validation"
            if ! terraform init -backend=false 2>&1; then
              echo "❌ Terraform initialization failed with local backend"
              exit 1
            fi
          fi

          echo "✅ Terraform initialization successful"

          # Run validation
          echo "🔍 Running terraform validate..."
          if ! terraform validate 2>&1; then
            echo "❌ Infrastructure validation failed"
            exit 1
          fi

          echo "✅ Infrastructure validation successful for environment: $environment"

  setup-backend:
    name: Setup Terraform Backend
    needs: validate
    if: needs.validate.outputs.deploy_env != ''
    uses: ./.github/workflows/manage-backend-bucket.yml
    with:
      bucket_name: ${{ inputs.bucket_name }}
      environment: ${{ needs.validate.outputs.deploy_env }}
      region: ${{ inputs.region }}
      action: create
      force_recreate: false
    secrets: inherit

  estimate-costs:
    name: Estimate Infrastructure Costs
    runs-on: ubuntu-latest
    needs: [validate, setup-backend]
    if: needs.validate.outputs.deploy_env != '' && needs.setup-backend.outputs.backend_configured == 'true'
    permissions:
      contents: read        # Read repository code
      pull-requests: write  # Comment cost estimates on PRs

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Calculate Infrastructure Cost Estimate
        id: cost-estimate
        run: |
          environment="${{ needs.validate.outputs.deploy_env }}"

          # Infrastructure-only cost estimation (excluding Coder application costs)
          case "$environment" in
            dev)
              monthly_cost="45.20"
              description="2×GP1-XS nodes, DB-DEV-S, Basic LB (Infrastructure Only)"
              ;;
            staging)
              monthly_cost="85.50"
              description="3×GP1-S nodes, DB-GP-S, Basic LB (Infrastructure Only)"
              ;;
            prod)
              monthly_cost="320.30"
              description="5×GP1-M nodes, DB-GP-M HA, Enhanced LB (Infrastructure Only)"
              ;;
          esac

          echo "monthly_cost=$monthly_cost" >> $GITHUB_OUTPUT
          echo "description=$description" >> $GITHUB_OUTPUT
          echo "environment=$environment" >> $GITHUB_OUTPUT

      - name: Comment Infrastructure Cost Estimate on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const { monthly_cost, description, environment } = ${{ steps.cost-estimate.outputs }};

            const body = `## 🏗️ Infrastructure Cost Impact Analysis

            **Environment:** \`${environment}\`
            **Estimated Monthly Cost:** €${monthly_cost}
            **Resources:** ${description}

            > This is an estimate for infrastructure components only (cluster, database, networking, security). Coder application deployment is handled separately.

            **Domain:** ${{ needs.validate.outputs.deploy_domain || 'IP-based access' }}`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  plan:
    name: Plan Infrastructure Changes
    runs-on: ubuntu-latest
    needs: [validate, setup-backend, estimate-costs]
    if: needs.validate.outputs.deploy_env != '' && needs.setup-backend.outputs.backend_configured == 'true'
    permissions:
      contents: read        # Read repository code
      pull-requests: write  # Comment plan results on PRs
    outputs:
      plan_id: ${{ steps.plan.outputs.plan_id }}
      has_changes: ${{ steps.plan.outputs.has_changes }}
      plan_summary: ${{ steps.plan.outputs.plan_summary }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.12.0"
          terraform_wrapper: false

      - name: Download Backend Configuration
        uses: actions/download-artifact@v4
        with:
          name: backend-config-${{ needs.validate.outputs.deploy_env }}-${{ github.run_id }}
          path: environments/${{ needs.validate.outputs.deploy_env }}/infra

      - name: Verify Backend Configuration
        run: |
          echo "🔍 Verifying infrastructure backend configuration..."

          ENVIRONMENT="${{ needs.validate.outputs.deploy_env }}"
          BACKEND_FILE="environments/$ENVIRONMENT/infra/backend.tf"
          ENV_DIR="environments/$ENVIRONMENT/infra"

          if [ ! -f "$BACKEND_FILE" ]; then
            echo "❌ ERROR: backend.tf not found at: $BACKEND_FILE"
            exit 1
          fi

          echo "✅ backend.tf found at: $BACKEND_FILE"
          echo "📄 Backend configuration content:"
          cat "$BACKEND_FILE"

      - name: Initialize Terraform Backend
        run: |
          cd environments/${{ needs.validate.outputs.deploy_env }}/infra

          echo "🔄 Initializing infrastructure with remote backend..."
          echo "Backend bucket: ${{ needs.setup-backend.outputs.bucket_name }}"
          terraform init

      - name: Plan Infrastructure Changes
        id: plan
        run: |
          cd environments/${{ needs.validate.outputs.deploy_env }}/infra

          # Generate unique plan ID
          plan_id="infra-plan-$(date +%Y%m%d-%H%M%S)-${{ github.run_id }}"
          echo "plan_id=$plan_id" >> $GITHUB_OUTPUT

          # Run terraform plan
          set +e
          terraform plan -detailed-exitcode -out="${plan_id}.tfplan" > plan_output.txt 2>&1
          plan_exit_code=$?
          set -e

          # Parse plan results
          case $plan_exit_code in
            0)
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "plan_summary=No infrastructure changes needed" >> $GITHUB_OUTPUT
              ;;
            1)
              echo "❌ Infrastructure plan failed"
              cat plan_output.txt
              exit 1
              ;;
            2)
              echo "has_changes=true" >> $GITHUB_OUTPUT

              # Extract plan summary
              if grep -q "Plan:" plan_output.txt; then
                plan_summary=$(grep "Plan:" plan_output.txt | head -1)
                echo "plan_summary=$plan_summary" >> $GITHUB_OUTPUT
              else
                echo "plan_summary=Infrastructure changes detected" >> $GITHUB_OUTPUT
              fi
              ;;
          esac

          # Save plan output for artifacts
          cp plan_output.txt "terraform-plan-${plan_id}.txt"

      - name: Upload Infrastructure Plan Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-infra-plan-${{ needs.validate.outputs.deploy_env }}-${{ github.run_id }}
          path: |
            environments/${{ needs.validate.outputs.deploy_env }}/infra/*.tfplan
            environments/${{ needs.validate.outputs.deploy_env }}/infra/terraform-plan-*.txt
          retention-days: 30

      - name: Comment Infrastructure Plan Results on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const planFile = `environments/${{ needs.validate.outputs.deploy_env }}/infra/terraform-plan-${{ steps.plan.outputs.plan_id }}.txt`;
            let planOutput = '';

            try {
              planOutput = fs.readFileSync(planFile, 'utf8');
            } catch (error) {
              planOutput = 'Plan output not available';
            }

            const body = `## 🏗️ Infrastructure Plan Results (Phase 1)

            **Environment:** \`${{ needs.validate.outputs.deploy_env }}\`
            **Plan ID:** \`${{ steps.plan.outputs.plan_id }}\`
            **Has Changes:** ${{ steps.plan.outputs.has_changes }}
            **Summary:** ${{ steps.plan.outputs.plan_summary }}

            <details>
            <summary>View Infrastructure Plan Details</summary>

            \`\`\`terraform
            ${planOutput.slice(0, 32000)} ${planOutput.length > 32000 ? '... (truncated)' : ''}
            \`\`\`

            </details>

            ${steps.plan.outputs.has_changes === 'true' ? '⚠️ **Review the infrastructure changes carefully before approving deployment**' : '✅ **No infrastructure changes needed**'}

            📝 **Note:** This is Phase 1 (Infrastructure Only). Coder application deployment will happen in Phase 2.`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  deploy:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [validate, setup-backend, estimate-costs, plan]
    if: needs.validate.outputs.deploy_env != '' && needs.setup-backend.outputs.backend_configured == 'true' && (inputs.dry_run != true)
    environment:
      name: ${{ needs.validate.outputs.deploy_env }}-infra
      url: ${{ steps.deploy.outputs.access_url }}
    outputs:
      access_url: ${{ steps.deploy.outputs.access_url }}
      wildcard_access_url: ${{ steps.deploy.outputs.wildcard_access_url }}
      load_balancer_ip: ${{ steps.deploy.outputs.load_balancer_ip }}
      cluster_name: ${{ steps.deploy.outputs.cluster_name }}
      database_host: ${{ steps.deploy.outputs.database_host }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.12.0"
          terraform_wrapper: false

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.32.0'

      - name: Download Infrastructure Plan Artifacts
        uses: actions/download-artifact@v4
        with:
          name: terraform-infra-plan-${{ needs.validate.outputs.deploy_env }}-${{ github.run_id }}
          path: environments/${{ needs.validate.outputs.deploy_env }}/infra/

      - name: Download Backend Configuration
        uses: actions/download-artifact@v4
        with:
          name: backend-config-${{ needs.validate.outputs.deploy_env }}-${{ github.run_id }}
          path: environments/${{ needs.validate.outputs.deploy_env }}/infra

      - name: Initialize Terraform Backend
        run: |
          cd environments/${{ needs.validate.outputs.deploy_env }}/infra

          echo "🔄 Initializing infrastructure with remote backend..."
          echo "Backend bucket: ${{ needs.setup-backend.outputs.bucket_name }}"
          terraform init

      - name: Apply Infrastructure Changes
        id: apply
        run: |
          cd environments/${{ needs.validate.outputs.deploy_env }}/infra

          # Find the plan file
          plan_file=$(ls *.tfplan 2>/dev/null | head -1 || echo "")

          if [[ -n "$plan_file" ]] && [[ -f "$plan_file" ]]; then
            echo "📋 Applying planned infrastructure changes from: $plan_file"
            terraform apply -auto-approve "$plan_file"
          else
            echo "⚠️ No plan file found, running direct apply"
            if [[ "${{ inputs.auto_approve }}" == "true" ]]; then
              terraform apply -auto-approve
            else
              terraform apply
            fi
          fi

          echo "apply_completed=true" >> $GITHUB_OUTPUT

      - name: Extract Infrastructure Outputs
        id: deploy
        if: steps.apply.outputs.apply_completed == 'true'
        run: |
          cd environments/${{ needs.validate.outputs.deploy_env }}/infra

          # Extract infrastructure outputs
          access_url=$(terraform output -raw access_url 2>/dev/null || echo "")
          wildcard_access_url=$(terraform output -raw wildcard_access_url 2>/dev/null || echo "")
          load_balancer_ip=$(terraform output -raw load_balancer_ip 2>/dev/null || echo "")
          cluster_name=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          database_host=$(terraform output -raw database_host 2>/dev/null || echo "")

          echo "access_url=$access_url" >> $GITHUB_OUTPUT
          echo "wildcard_access_url=$wildcard_access_url" >> $GITHUB_OUTPUT
          echo "load_balancer_ip=$load_balancer_ip" >> $GITHUB_OUTPUT
          echo "cluster_name=$cluster_name" >> $GITHUB_OUTPUT
          echo "database_host=$database_host" >> $GITHUB_OUTPUT

          # Extract and save kubeconfig immediately after infrastructure deployment
          echo "🔄 Extracting kubeconfig from infrastructure outputs..."

          kubeconfig_content=$(terraform output -raw kubeconfig 2>/dev/null || echo "")

          if [[ -n "$kubeconfig_content" ]]; then
            # Create .kube directory if it doesn't exist
            mkdir -p "${HOME}/.kube"

            # Save kubeconfig to expected location
            kubeconfig_file="${HOME}/.kube/config-coder-${{ needs.validate.outputs.deploy_env }}"
            echo "$kubeconfig_content" > "$kubeconfig_file"

            # Set proper permissions for security
            chmod 600 "$kubeconfig_file"

            # Copy to artifact location
            cp "$kubeconfig_file" "../kubeconfig-${{ needs.validate.outputs.deploy_env }}"

            echo "✅ Kubeconfig saved to: $kubeconfig_file"
            echo "✅ Kubeconfig artifact created for Phase 2"
          else
            echo "⚠️  Warning: No kubeconfig content found in infrastructure output"
            exit 1
          fi

      - name: Upload Kubeconfig Artifact (Immediately Available)
        if: steps.apply.outputs.apply_completed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig-${{ needs.validate.outputs.deploy_env }}-infra
          path: environments/${{ needs.validate.outputs.deploy_env }}/kubeconfig-${{ needs.validate.outputs.deploy_env }}
          retention-days: 7

      - name: Validate Infrastructure Health
        if: steps.apply.outputs.apply_completed == 'true'
        run: |
          echo "🔍 Validating infrastructure health..."

          # Set kubeconfig for cluster access
          export KUBECONFIG="${HOME}/.kube/config-coder-${{ needs.validate.outputs.deploy_env }}"

          # Wait for cluster to be ready
          echo "⏳ Waiting for cluster nodes to be ready..."
          kubectl wait --for=condition=Ready nodes --all --timeout=300s

          # Check cluster info
          echo "📊 Cluster information:"
          kubectl cluster-info
          kubectl get nodes -o wide

          # Check if storage classes are available (critical for Coder PVC)
          echo "💾 Checking storage classes..."
          kubectl get storageclass

          # Verify scw-bssd storage class exists
          if kubectl get storageclass scw-bssd >/dev/null 2>&1; then
            echo "✅ scw-bssd storage class is available"
          else
            echo "⚠️  Warning: scw-bssd storage class not found"
            echo "Available storage classes:"
            kubectl get storageclass -o name
          fi

          echo "✅ Infrastructure validation completed"

      - name: Display Infrastructure Summary
        if: steps.apply.outputs.apply_completed == 'true'
        run: |
          echo "🎉 Infrastructure Deployment Completed Successfully!"
          echo "=================================================="
          echo ""
          echo "📋 Infrastructure Summary:"
          echo "  Environment: ${{ needs.validate.outputs.deploy_env }}"
          echo "  Cluster: ${{ steps.deploy.outputs.cluster_name }}"
          echo "  Access URL: ${{ steps.deploy.outputs.access_url }}"
          echo "  Load Balancer IP: ${{ steps.deploy.outputs.load_balancer_ip }}"
          echo "  Database Host: ${{ steps.deploy.outputs.database_host }}"
          echo ""
          echo "🔧 Next Steps:"
          echo "  1. ✅ Infrastructure is ready"
          echo "  2. ✅ Kubeconfig is available for troubleshooting"
          echo "  3. 🔄 Ready for Coder deployment (Phase 2)"
          echo ""
          echo "🎯 To deploy Coder application, run the 'Deploy Coder Application' workflow"
          echo "   or use the full environment deployment workflow."

      - name: Comment Infrastructure Success on PR
        if: github.event_name == 'pull_request' && steps.apply.outputs.apply_completed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const body = `## ✅ Infrastructure Deployment Successful (Phase 1)

            **Environment:** \`${{ needs.validate.outputs.deploy_env }}\`
            **Cluster:** ${{ steps.deploy.outputs.cluster_name }}
            **Access URL:** ${{ steps.deploy.outputs.access_url }}
            **Load Balancer IP:** ${{ steps.deploy.outputs.load_balancer_ip }}
            **Database Host:** ${{ steps.deploy.outputs.database_host }}

            ## 🔧 Infrastructure Status
            - ✅ Kubernetes cluster deployed and ready
            - ✅ Database instance created and accessible
            - ✅ Networking and load balancer configured
            - ✅ Security policies applied
            - ✅ Storage classes available for persistent volumes

            ## 📋 Next Steps
            - **Kubeconfig Available:** Ready for troubleshooting if needed
            - **Phase 2:** Deploy Coder application using the 'Deploy Coder Application' workflow

            🎯 **Infrastructure is ready for Coder deployment!**`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  notify:
    name: Notify Infrastructure Status
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    if: always() && needs.validate.outputs.deploy_env != ''
    permissions:
      contents: read  # Read repository information
      issues: write   # Create issues on deployment failure

    steps:
      - name: Notify Slack (if configured)
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [[ -n "$SLACK_WEBHOOK_URL" ]]; then
            status="${{ needs.deploy.result }}"
            environment="${{ needs.validate.outputs.deploy_env }}"

            if [[ "$status" == "success" ]]; then
              color="good"
              emoji="🏗️"
              text="Infrastructure deployment succeeded (Phase 1)"
            else
              color="danger"
              emoji="❌"
              text="Infrastructure deployment failed (Phase 1)"
            fi

            payload="{
              \"attachments\": [{
                \"color\": \"$color\",
                \"text\": \"$emoji $text\",
                \"fields\": [
                  {\"title\": \"Environment\", \"value\": \"$environment\", \"short\": true},
                  {\"title\": \"Phase\", \"value\": \"Infrastructure Only\", \"short\": true},
                  {\"title\": \"Triggered by\", \"value\": \"${{ github.actor }}\", \"short\": true},
                  {\"title\": \"Repository\", \"value\": \"${{ github.repository }}\", \"short\": true}
                ]
              }]
            }"

            curl -X POST -H 'Content-type: application/json' \
              --data "$payload" "$SLACK_WEBHOOK_URL"
          else
            echo "Slack webhook not configured, skipping notification"
          fi

      - name: Create GitHub Issue on Infrastructure Failure
        if: needs.deploy.result == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `Infrastructure Deployment Failed: ${{ needs.validate.outputs.deploy_env }} environment`;
            const body = `## Infrastructure Deployment Failure Report

            **Environment:** ${{ needs.validate.outputs.deploy_env }}
            **Phase:** Infrastructure Only (Phase 1)
            **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            **Triggered by:** ${{ github.actor }}
            **Commit:** ${{ github.sha }}

            The infrastructure deployment has failed. This affects the cluster, database, networking, and security components.

            ## Next Steps
            1. Review the workflow logs for infrastructure deployment
            2. Check Scaleway console for any resources that need cleanup
            3. Verify Scaleway credentials and quotas
            4. Check for resource conflicts or naming issues
            5. Re-run the infrastructure deployment after fixing issues

            ## Important Notes
            - No Coder application deployment was attempted (Phase 2 not reached)
            - Infrastructure components may be partially deployed
            - Check for orphaned resources in Scaleway console

            **Labels:** infrastructure-failure, deployment-failure, ${{ needs.validate.outputs.deploy_env }}`;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['infrastructure-failure', 'deployment-failure', '${{ needs.validate.outputs.deploy_env }}']
            });