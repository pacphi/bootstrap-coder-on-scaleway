name: Teardown Coder Environment

# Set minimal required permissions for security
permissions:
  contents: read   # Access repository code
  issues: write    # Create cleanup failure issues
  actions: read    # Download artifacts (kubeconfig)
  id-token: write  # For OIDC authentication if needed

on:
  workflow_dispatch:
    inputs:
      bucket_name:
        description: 'Name of the bucket in object store that holds Terraform state'
        required: false
        type: string
      environment:
        description: 'Environment to teardown'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      region:
        description: 'Scaleway region'
        required: true
        type: choice
        options:
          - fr-par
          - nl-ams
          - pl-waw
        default: 'fr-par'
      availability_zone:
        description: 'Scaleway availibility zone (which should be within region)'
        required: true
        type: choice
        options:
          - fr-par-1
          - fr-par-2
          - fr-par-3
          - nl-ams-1
          - nl-ams-2
          - nl-ams-3
          - pl-waw-1
          - pl-waw-2
          - pl-waw-3
        default: 'fr-par-1'
      confirmation:
        description: 'Type CONFIRM to proceed with teardown'
        required: true
        type: string
      backup_before_destroy:
        description: 'Create backup before teardown'
        required: false
        type: boolean
        default: true
      preserve_data:
        description: 'Preserve data volumes (experimental)'
        required: false
        type: boolean
        default: false
      emergency_mode:
        description: 'Emergency teardown (bypasses all safety checks)'
        required: false
        type: boolean
        default: false

env:
  TF_IN_AUTOMATION: true
  TF_VAR_scaleway_region: ${{ github.event.inputs.region }}
  TF_VAR_scaleway_zone: ${{ github.event.inputs.availability_zone }}
  # Consolidated Scaleway credentials and mappings
  SCW_ACCESS_KEY: ${{ secrets.SCW_ACCESS_KEY }}
  SCW_SECRET_KEY: ${{ secrets.SCW_SECRET_KEY }}
  SCW_DEFAULT_PROJECT_ID: ${{ secrets.SCW_DEFAULT_PROJECT_ID }}
  SCW_DEFAULT_ORGANIZATION_ID: ${{ secrets.SCW_DEFAULT_ORGANIZATION_ID }}
  # AWS variables for S3 backend compatibility
  AWS_ACCESS_KEY_ID: ${{ secrets.SCW_ACCESS_KEY }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.SCW_SECRET_KEY }}

jobs:
  validate-request:
    name: Validate Teardown Request
    runs-on: ubuntu-latest
    permissions:
      contents: read  # Read repository code for validation
    outputs:
      confirmed: ${{ steps.validation.outputs.confirmed }}

    steps:
      - name: Validate Confirmation
        id: validation
        run: |
          if [[ "${{ github.event.inputs.confirmation }}" == "CONFIRM" ]]; then
            echo "confirmed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Teardown request confirmed"
          else
            echo "confirmed=false" >> $GITHUB_OUTPUT
            echo "‚ùå Invalid confirmation. Please type 'CONFIRM' to proceed."
            exit 1
          fi

      - name: Extra Production Validation
        if: github.event.inputs.environment == 'prod'
        run: |
          echo "üî¥ PRODUCTION ENVIRONMENT TEARDOWN REQUESTED"
          echo "This will PERMANENTLY DELETE the production environment!"
          echo "Proceeding with additional safety checks..."

  pre-teardown-backup:
    name: Create Pre-Teardown Backup
    runs-on: ubuntu-latest
    needs: validate-request
    if: needs.validate-request.outputs.confirmed == 'true' && github.event.inputs.backup_before_destroy == 'true'
    permissions:
      contents: read  # Read repository code
      actions: write  # Upload backup artifacts

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.32.0'


      - name: Download Kubeconfig
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig-${{ github.event.inputs.environment }}
          path: ./

      - name: Setup Kubeconfig
        continue-on-error: true
        run: |
          if [[ -f "kubeconfig-${{ github.event.inputs.environment }}" ]]; then
            mkdir -p ~/.kube
            cp "kubeconfig-${{ github.event.inputs.environment }}" ~/.kube/config-coder-${{ github.event.inputs.environment }}
            chmod 600 ~/.kube/config-coder-${{ github.event.inputs.environment }}
          fi

      - name: Create Pre-Teardown Backup
        id: backup
        run: |
          chmod +x scripts/lifecycle/backup.sh

          backup_name="pre-teardown-$(date +%Y%m%d-%H%M%S)-${{ github.event.inputs.environment }}"

          ./scripts/lifecycle/backup.sh \
            --env=${{ github.event.inputs.environment }} \
            --backup-name="$backup_name" \
            --pre-destroy \
            --auto

          echo "backup_name=$backup_name" >> $GITHUB_OUTPUT

      - name: Upload Backup Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.backup.outputs.backup_name }}
          path: backups/${{ steps.backup.outputs.backup_name }}
          retention-days: 30

  analyze-impact:
    name: Analyze Teardown Impact
    runs-on: ubuntu-latest
    needs: validate-request
    if: needs.validate-request.outputs.confirmed == 'true'
    permissions:
      contents: read  # Read repository code
      actions: read   # Download kubeconfig artifacts
    outputs:
      cost_savings: ${{ steps.impact.outputs.cost_savings }}
      active_workspaces: ${{ steps.impact.outputs.active_workspaces }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.12.0"
          terraform_wrapper: false

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.32.0'


      - name: Analyze Impact
        id: impact
        run: |
          environment="${{ github.event.inputs.environment }}"

          # Calculate cost savings
          case "$environment" in
            dev) cost_savings="53.70" ;;
            staging) cost_savings="97.85" ;;
            prod) cost_savings="374.50" ;;
          esac

          echo "cost_savings=$cost_savings" >> $GITHUB_OUTPUT

          # Check for active workspaces (if kubeconfig available)
          active_workspaces="Unknown"
          if [[ -f "kubeconfig-$environment" ]]; then
            export KUBECONFIG="kubeconfig-$environment"
            if kubectl cluster-info &>/dev/null; then
              active_workspaces=$(kubectl get pods -n coder --no-headers 2>/dev/null | grep -c "workspace" || echo "0")
            fi
          fi

          echo "active_workspaces=$active_workspaces" >> $GITHUB_OUTPUT

      - name: Download Kubeconfig for Analysis
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig-${{ github.event.inputs.environment }}
          path: ./

  discover-backend-state:
    name: Discover Existing Backend State
    runs-on: ubuntu-latest
    needs: validate-request
    if: needs.validate-request.outputs.confirmed == 'true'
    permissions:
      contents: read  # Read repository code
      actions: read   # Download artifacts from previous workflows
    outputs:
      bucket_exists: ${{ steps.discover.outputs.bucket_exists }}
      state_exists: ${{ steps.discover.outputs.state_exists }}
      bucket_name: ${{ steps.discover.outputs.bucket_name }}
      resource_count: ${{ steps.validate-state.outputs.resource_count }}
      state_valid: ${{ steps.discover.outputs.state_valid }}
      backend_generated: ${{ steps.generate-backend.outputs.backend_generated }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.12.0"
          terraform_wrapper: false

      - name: Setup Scaleway CLI
        uses: scaleway/action-scw@v0
        with:
          save-config: true
          export-config: true
          access-key: ${{ env.SCW_ACCESS_KEY }}
          secret-key: ${{ env.SCW_SECRET_KEY }}
          default-project-id: ${{ env.SCW_DEFAULT_PROJECT_ID }}
          default-organization-id: ${{ env.SCW_DEFAULT_ORGANIZATION_ID }}

      - name: Install s3cmd
        run: sudo apt-get update && sudo apt-get install -y s3cmd

      - name: Generate s3cmd configuration using Scaleway CLI
        run: |
          scw object config get type=s3cmd > ~/.s3cfg
          echo "‚úÖ s3cmd configured for Scaleway Object Storage"

      - name: Discover Existing Backend Bucket
        id: discover
        run: |
          environment="${{ github.event.inputs.environment }}"
          region="${{ github.event.inputs.region }}"
          expected_bucket_name="${{ github.event.inputs.bucket_name }}"

          # Determine expected bucket name if not provided
          if [[ -z "$expected_bucket_name" ]]; then
            expected_bucket_name="terraform-state-coder-${environment}"
          fi

          echo "üîç Discovering existing backend for environment: $environment"
          echo "Expected bucket: $expected_bucket_name"
          echo "Region: $region"

          # Check if the expected bucket exists using Scaleway CLI
          echo "üîç Checking if bucket exists..."
          if scw object bucket list region="$region" --output=json | jq -r '.[] | .Name' | grep -q "^${expected_bucket_name}$"; then
            echo "‚úÖ Found existing bucket: $expected_bucket_name"
            echo "bucket_exists=true" >> $GITHUB_OUTPUT
            echo "bucket_name=$expected_bucket_name" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Expected bucket not found: $expected_bucket_name"
            echo ""
            echo "üö® TEARDOWN FAILURE: STATE BUCKET MISSING"
            echo "========================================"
            echo ""
            echo "The expected Terraform state bucket does not exist:"
            echo "  Expected bucket: $expected_bucket_name"
            echo "  Region: $region"
            echo ""
            echo "This indicates one of the following:"
            echo "  1. Environment was never properly deployed"
            echo "  2. Backend infrastructure was manually deleted"
            echo "  3. Infrastructure exists but bucket name is different"
            echo ""
            echo "MANUAL ACTIONS REQUIRED:"
            echo "  1. Check Scaleway console for existing buckets"
            echo "  2. Verify if infrastructure exists without state"
            echo "  3. Manually delete any orphaned resources"
            echo "  4. If bucket exists with different name, update workflow inputs"
            echo ""
            echo "Available buckets in region $region:"
            scw object bucket list region="$region" --output=table || echo "  No buckets found or access denied"
            echo ""
            echo "bucket_exists=false" >> $GITHUB_OUTPUT
            echo "state_exists=false" >> $GITHUB_OUTPUT
            echo "bucket_name=$expected_bucket_name" >> $GITHUB_OUTPUT
            echo "resource_count=0" >> $GITHUB_OUTPUT
            echo "state_valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Check if state file exists in the bucket
          state_key="${environment}/terraform.tfstate"
          echo "üîç Checking for state file: $state_key"

          if s3cmd ls "s3://$expected_bucket_name/$state_key" >/dev/null 2>&1; then
            echo "‚úÖ Found state file: $state_key"
            echo "state_exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå State file not found: $state_key"
            echo ""
            echo "üö® TEARDOWN FAILURE: STATE FILE MISSING"
            echo "======================================="
            echo ""
            echo "The bucket exists but contains no state file:"
            echo "  Bucket: $expected_bucket_name"
            echo "  Expected state key: $state_key"
            echo ""
            echo "This indicates:"
            echo "  1. Environment was never deployed (empty bucket)"
            echo "  2. State file was manually deleted"
            echo "  3. Different state key naming convention"
            echo ""
            echo "MANUAL ACTIONS REQUIRED:"
            echo "  1. Check bucket contents in Scaleway console"
            echo "  2. Verify if infrastructure exists without state"
            echo "  3. Manually delete any orphaned resources"
            echo ""
            echo "Files in bucket $expected_bucket_name:"
            s3cmd ls "s3://$expected_bucket_name/" || echo "  Bucket is empty or access denied"
            echo ""
            echo "state_exists=false" >> $GITHUB_OUTPUT
            echo "bucket_name=$expected_bucket_name" >> $GITHUB_OUTPUT
            echo "resource_count=0" >> $GITHUB_OUTPUT
            echo "state_valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "state_valid=true" >> $GITHUB_OUTPUT

      - name: Generate Backend Configuration
        id: generate-backend
        if: steps.discover.outputs.bucket_exists == 'true' && steps.discover.outputs.state_exists == 'true'
        run: |
          environment="${{ github.event.inputs.environment }}"
          region="${{ github.event.inputs.region }}"
          bucket_name="${{ steps.discover.outputs.bucket_name }}"

          echo "üìù Generating backend configuration for discovered bucket..."

          # Create backend.tf for the environment
          backend_file="environments/$environment/backend.tf"
          mkdir -p "environments/$environment"

          cat > "$backend_file" << EOF
          terraform {
            backend "s3" {
              bucket = "$bucket_name"
              key    = "$environment/terraform.tfstate"
              region = "$region"

              # S3-compatibility flags for Scaleway Object Storage
              skip_credentials_validation = true
              skip_region_validation      = true
              skip_requesting_account_id  = true

              # Use Scaleway S3-compatible endpoint
              endpoints = {
                s3 = "https://s3.$region.scw.cloud"
              }
            }
          }
          EOF

          echo "‚úÖ Backend configuration generated: $backend_file"
          echo "backend_generated=true" >> $GITHUB_OUTPUT

      - name: Validate State Content
        id: validate-state
        if: steps.discover.outputs.state_valid == 'true'
        run: |
          environment="${{ github.event.inputs.environment }}"

          echo "üîç Validating state content..."

          # Initialize Terraform with the generated backend
          cd "environments/$environment"

          echo "üì¶ Initializing Terraform with discovered backend..."
          if ! terraform init -input=false; then
            echo "‚ùå Failed to initialize Terraform with discovered backend"
            echo ""
            echo "üö® TEARDOWN FAILURE: BACKEND INITIALIZATION FAILED"
            echo "=================================================="
            echo ""
            echo "Cannot initialize Terraform with the discovered backend:"
            echo "  Bucket: ${{ steps.discover.outputs.bucket_name }}"
            echo "  State key: $environment/terraform.tfstate"
            echo "  Region: ${{ github.event.inputs.region }}"
            echo ""
            echo "Possible causes:"
            echo "  1. Invalid credentials or permissions"
            echo "  2. State file is corrupted"
            echo "  3. Backend configuration mismatch"
            echo ""
            echo "MANUAL ACTIONS REQUIRED:"
            echo "  1. Verify Scaleway credentials and permissions"
            echo "  2. Check state file integrity in bucket"
            echo "  3. Manually inspect and clean up resources if needed"
            echo ""
            exit 1
          fi

          echo "‚úÖ Backend initialization successful"

          # Check if we can access the state
          echo "üîç Checking remote state accessibility..."
          if ! terraform state pull > /dev/null 2>&1; then
            echo "‚ùå Cannot access remote state"
            echo ""
            echo "üö® TEARDOWN FAILURE: STATE NOT ACCESSIBLE"
            echo "========================================"
            echo ""
            echo "Backend initialized but state is not accessible:"
            echo "  This may indicate corrupted or encrypted state"
            echo ""
            echo "MANUAL ACTIONS REQUIRED:"
            echo "  1. Check state file permissions and integrity"
            echo "  2. Verify encryption settings if applicable"
            echo "  3. Download state manually and inspect"
            echo "  4. Manually clean up resources if state is unrecoverable"
            echo ""
            exit 1
          fi

          echo "‚úÖ Remote state accessible"

          # Get resource count from state
          resource_count=$(terraform state list 2>/dev/null | wc -l || echo "0")
          echo "üìä Resources found in state: $resource_count"

          if [[ "$resource_count" -eq 0 ]]; then
            echo "‚ö†Ô∏è TEARDOWN NOTICE: NO RESOURCES IN STATE"
            echo "======================================="
            echo ""
            echo "The state file exists but contains no resources:"
            echo "  This indicates the environment was already destroyed"
            echo "  or resources were removed outside of Terraform"
            echo ""
            echo "RECOMMENDATIONS:"
            echo "  1. Verify no resources exist in Scaleway console"
            echo "  2. Clean up the empty state bucket if desired"
            echo "  3. No further teardown action needed"
            echo ""
            echo "resource_count=0" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ State contains $resource_count resources ready for teardown"
            echo "resource_count=$resource_count" >> $GITHUB_OUTPUT

            # Show resource summary
            echo ""
            echo "Resources to be destroyed:"
            echo "========================="
            terraform state list | head -10
            if [[ "$resource_count" -gt 10 ]]; then
              echo "... and $((resource_count - 10)) more resources"
            fi
            echo ""
          fi

      - name: Upload Backend Configuration
        if: steps.generate-backend.outputs.backend_generated == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: backend-config-${{ github.event.inputs.environment }}-${{ github.run_id }}
          path: |
            environments/${{ github.event.inputs.environment }}/backend.tf
          retention-days: 1

  prepare-teardown:
    name: Prepare Teardown
    runs-on: ubuntu-latest
    needs: [validate-request, discover-backend-state]
    if: |
      needs.validate-request.outputs.confirmed == 'true' &&
      needs.discover-backend-state.outputs.state_valid == 'true' &&
      needs.discover-backend-state.outputs.resource_count != '0'
    permissions:
      contents: read  # Read repository code
    outputs:
      drift_detected: ${{ steps.drift-check.outputs.drift_detected }}
      resource_inventory: ${{ steps.inventory.outputs.resource_count }}
      ready_for_teardown: ${{ steps.prepare.outputs.ready_for_teardown }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.12.0"
          terraform_wrapper: false

      - name: Download Backend Configuration
        uses: actions/download-artifact@v4
        with:
          name: backend-config-${{ github.event.inputs.environment }}-${{ github.run_id }}
          path: ./environments/${{ github.event.inputs.environment }}/

      - name: Initialize Terraform for Drift Check
        run: |
          cd environments/${{ github.event.inputs.environment }}
          echo "üîÑ Initializing Terraform for drift detection..."
          terraform init -input=false

      - name: Check Configuration Drift
        id: drift-check
        continue-on-error: true
        run: |
          cd environments/${{ github.event.inputs.environment }}

          echo "üîç Checking for configuration drift..."

          # Run terraform plan to detect drift
          if terraform plan -detailed-exitcode -out=drift.tfplan; then
            plan_exit_code=$?
          else
            plan_exit_code=$?
          fi

          case $plan_exit_code in
            0)
              echo "‚úÖ No drift detected - infrastructure matches configuration"
              echo "drift_detected=false" >> $GITHUB_OUTPUT
              ;;
            1)
              echo "‚ùå Error running terraform plan for drift detection"
              echo "drift_detected=error" >> $GITHUB_OUTPUT
              exit 1
              ;;
            2)
              echo "‚ö†Ô∏è Configuration drift detected"
              echo "drift_detected=true" >> $GITHUB_OUTPUT

              echo "Drift Details:"
              echo "=============="
              terraform show drift.tfplan
              echo ""
              echo "This means some resources may have been modified outside of Terraform."
              echo "Teardown will attempt to destroy all resources regardless of drift."
              ;;
          esac

          # Clean up plan file
          rm -f drift.tfplan

      - name: Create Resource Inventory
        id: inventory
        run: |
          cd environments/${{ github.event.inputs.environment }}

          echo "üìã Creating detailed resource inventory..."

          # Get detailed resource list
          terraform state list > resource_list.txt
          resource_count=$(wc -l < resource_list.txt)

          echo "üìä Total resources to destroy: $resource_count"
          echo "resource_count=$resource_count" >> $GITHUB_OUTPUT

          # Categorize resources by type
          echo "Resource breakdown by type:"
          terraform state list | cut -d. -f1 | sort | uniq -c | sort -nr | head -10

          # Create inventory file
          cat > resource_inventory.json << EOF
          {
            "environment": "${{ github.event.inputs.environment }}",
            "timestamp": "$(date -Iseconds)",
            "total_resources": $resource_count,
            "resource_types": $(terraform state list | cut -d. -f1 | sort | uniq -c | jq -R 'split(" ") | {count: .[0] | tonumber, type: .[1]}' | jq -s '.'),
            "drift_detected": "${{ steps.drift-check.outputs.drift_detected }}",
            "validation_status": "ready_for_teardown"
          }
          EOF

          echo "Inventory created: resource_inventory.json"

      - name: Final Preparation Check
        id: prepare
        run: |
          cd environments/${{ github.event.inputs.environment }}

          echo "üîß Final preparation checks..."

          # Verify state is still accessible
          if ! terraform state pull > /dev/null 2>&1; then
            echo "‚ùå State is no longer accessible"
            echo "ready_for_teardown=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Verify resource count hasn't changed significantly
          current_count=$(terraform state list | wc -l)
          expected_count="${{ needs.discover-backend-state.outputs.resource_count }}"

          if [[ "$current_count" != "$expected_count" ]]; then
            difference=$((current_count - expected_count))
            echo "‚ö†Ô∏è Resource count changed during preparation"
            echo "Expected: $expected_count, Current: $current_count, Difference: $difference"

            # Allow small differences (up to 5% or 2 resources)
            max_diff=$(( expected_count / 20 ))
            if [[ $max_diff -lt 2 ]]; then
              max_diff=2
            fi

            if [[ ${difference#-} -gt $max_diff ]]; then
              echo "‚ùå Significant resource count change detected"
              echo "This may indicate concurrent modifications to the infrastructure"
              echo "ready_for_teardown=false" >> $GITHUB_OUTPUT
              exit 1
            else
              echo "‚úÖ Resource count difference within acceptable range"
            fi
          else
            echo "‚úÖ Resource count stable: $current_count resources"
          fi

          echo "ready_for_teardown=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Environment ready for teardown"

      - name: Upload Resource Inventory
        uses: actions/upload-artifact@v4
        with:
          name: resource-inventory-${{ github.event.inputs.environment }}-${{ github.run_id }}
          path: |
            environments/${{ github.event.inputs.environment }}/resource_inventory.json
            environments/${{ github.event.inputs.environment }}/resource_list.txt
          retention-days: 30

  teardown:
    name: Execute Teardown
    runs-on: ubuntu-latest
    needs: [validate-request, discover-backend-state, prepare-teardown, analyze-impact]
    if: |
      needs.validate-request.outputs.confirmed == 'true' &&
      needs.discover-backend-state.outputs.state_valid == 'true' &&
      (needs.prepare-teardown.outputs.ready_for_teardown == 'true' ||
       needs.discover-backend-state.outputs.resource_count == '0') &&
      (needs.pre-teardown-backup.result == 'success' ||
       needs.pre-teardown-backup.result == 'skipped' ||
       github.event.inputs.backup_before_destroy == 'false')
    environment:
      name: ${{ github.event.inputs.environment }}-teardown

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.12.0"
          terraform_wrapper: false

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.32.0'


      - name: Download Kubeconfig
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig-${{ github.event.inputs.environment }}
          path: ./

      - name: Setup Kubeconfig
        continue-on-error: true
        run: |
          if [[ -f "kubeconfig-${{ github.event.inputs.environment }}" ]]; then
            mkdir -p ~/.kube
            cp "kubeconfig-${{ github.event.inputs.environment }}" ~/.kube/config-coder-${{ github.event.inputs.environment }}
            chmod 600 ~/.kube/config-coder-${{ github.event.inputs.environment }}
          fi

      - name: Final Confirmation for Production
        if: github.event.inputs.environment == 'prod'
        run: |
          echo "üî¥ FINAL PRODUCTION TEARDOWN CONFIRMATION üî¥"
          echo "About to PERMANENTLY DELETE the production environment!"
          echo "Resources in state: ${{ needs.discover-backend-state.outputs.resource_count }}"
          echo "Active workspaces: ${{ needs.analyze-impact.outputs.active_workspaces }}"
          echo "Monthly cost savings: ‚Ç¨${{ needs.analyze-impact.outputs.cost_savings }}"
          echo ""
          echo "This action is IRREVERSIBLE!"

          if [[ "${{ needs.discover-backend-state.outputs.resource_count }}" -eq 0 ]]; then
            echo "‚ö†Ô∏è WARNING: No resources found in state."
            echo "Environment may already be destroyed or was never deployed."
          fi

      - name: Setup Teardown Flags
        id: setup-flags
        run: |
          flags="--env=${{ github.event.inputs.environment }} --confirm"

          if [[ "${{ github.event.inputs.emergency_mode }}" == "true" ]]; then
            flags="$flags --emergency"
          fi

          if [[ "${{ github.event.inputs.preserve_data }}" == "true" ]]; then
            flags="$flags --preserve-data"
          fi

          if [[ "${{ github.event.inputs.backup_before_destroy }}" == "false" ]]; then
            flags="$flags --no-backup"
          fi

          echo "teardown_flags=$flags" >> $GITHUB_OUTPUT

      - name: Download Backend Configuration
        uses: actions/download-artifact@v4
        with:
          name: backend-config-${{ github.event.inputs.environment }}-${{ github.run_id }}
          path: ./environments/${{ github.event.inputs.environment }}/

      - name: Initialize Terraform Backend
        run: |
          cd environments/${{ github.event.inputs.environment }}

          echo "üîÑ Initializing with remote backend..."
          echo "Backend bucket: ${{ needs.discover-backend-state.outputs.bucket_name }}"
          echo "Resources to destroy: ${{ needs.discover-backend-state.outputs.resource_count }}"
          terraform init

          # Verify state matches what we validated earlier
          current_resources=$(terraform state list 2>/dev/null | wc -l || echo "0")
          expected_resources="${{ needs.discover-backend-state.outputs.resource_count }}"

          if [[ "$current_resources" != "$expected_resources" ]]; then
            echo "‚ö†Ô∏è WARNING: Resource count mismatch!"
            echo "Expected: $expected_resources, Found: $current_resources"
            echo "State may have changed since validation"
          else
            echo "‚úÖ State validation confirmed: $current_resources resources"
          fi

      - name: Download Resource Inventory
        if: needs.prepare-teardown.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: resource-inventory-${{ github.event.inputs.environment }}-${{ github.run_id }}
          path: ./inventory/

      - name: Plan Teardown Changes
        id: plan-destroy
        run: |
          cd environments/${{ github.event.inputs.environment }}

          echo "üìã Planning teardown changes..."

          # Show drift status if prepare-teardown ran
          if [[ "${{ needs.prepare-teardown.result }}" == "success" ]]; then
            drift_status="${{ needs.prepare-teardown.outputs.drift_detected }}"
            if [[ "$drift_status" == "true" ]]; then
              echo "‚ö†Ô∏è Configuration drift was detected during preparation"
              echo "Some resources may not match Terraform configuration"
            fi
          fi

          # Create destroy plan with retries
          max_attempts=3
          attempt=1

          while [[ $attempt -le $max_attempts ]]; do
            echo "üìã Attempt $attempt/$max_attempts: Creating destroy plan..."

            if terraform plan -destroy -detailed-exitcode -out=destroy.tfplan; then
              echo "‚úÖ Destroy plan created successfully"
              echo "destroy_plan_created=true" >> $GITHUB_OUTPUT
              break
            else
              plan_exit_code=$?
              if [[ $plan_exit_code -eq 2 ]]; then
                echo "‚úÖ Destroy plan created with changes (exit code 2)"
                echo "destroy_plan_created=true" >> $GITHUB_OUTPUT
                break
              else
                echo "‚ùå Failed to create destroy plan (attempt $attempt/$max_attempts)"
                if [[ $attempt -eq $max_attempts ]]; then
                  echo "destroy_plan_created=false" >> $GITHUB_OUTPUT
                  exit 1
                fi
                echo "Retrying in 10 seconds..."
                sleep 10
                ((attempt++))
              fi
            fi
          done

          # Show what will be destroyed
          echo ""
          echo "Resources to be destroyed:"
          terraform show -no-color destroy.tfplan | grep -E "^  # .* will be destroyed" | head -10
          total_to_destroy=$(terraform show -json destroy.tfplan | jq '.resource_changes[] | select(.change.actions[] == "delete") | .address' | wc -l)
          echo "Total resources to destroy: $total_to_destroy"

      - name: Execute Teardown
        id: teardown
        if: steps.plan-destroy.outputs.destroy_plan_created == 'true'
        run: |
          cd environments/${{ github.event.inputs.environment }}

          echo "üî• Executing infrastructure teardown..."

          # Attempt teardown with retries for transient failures
          max_attempts=2
          attempt=1

          while [[ $attempt -le $max_attempts ]]; do
            echo "üî• Attempt $attempt/$max_attempts: Applying destroy plan..."

            if terraform apply -auto-approve destroy.tfplan; then
              echo "‚úÖ Teardown completed successfully"
              echo "teardown_completed=true" >> $GITHUB_OUTPUT
              break
            else
              echo "‚ùå Teardown failed (attempt $attempt/$max_attempts)"

              # Check if partial teardown occurred
              remaining_resources=$(terraform state list 2>/dev/null | wc -l || echo "unknown")
              echo "Resources remaining in state: $remaining_resources"

              if [[ $attempt -eq $max_attempts ]]; then
                echo "teardown_completed=false" >> $GITHUB_OUTPUT
                echo "partial_teardown=true" >> $GITHUB_OUTPUT

                # Create a new destroy plan for remaining resources
                echo "Creating new destroy plan for remaining resources..."
                if terraform plan -destroy -out=retry_destroy.tfplan; then
                  echo "Retry plan created - manual intervention may be needed"
                fi
                exit 1
              else
                echo "Retrying teardown in 30 seconds..."
                sleep 30
                # Refresh state and recreate plan for retry
                terraform refresh || true
                terraform plan -destroy -out=destroy.tfplan || true
                ((attempt++))
              fi
            fi
          done

      - name: Verify Complete Destruction
        id: verify
        continue-on-error: true
        run: |
          cd environments/${{ github.event.inputs.environment }}

          echo "üîç Verifying complete resource destruction..."

          # Check Terraform state first (most reliable)
          remaining_in_state=$(terraform state list 2>/dev/null | wc -l || echo "0")
          echo "Resources remaining in Terraform state: $remaining_in_state"

          if [[ "$remaining_in_state" -gt 0 ]]; then
            echo "‚ùå Teardown incomplete: $remaining_in_state resources remain in state"
            echo "Remaining resources:"
            terraform state list | head -10
            echo "verification_status=incomplete" >> $GITHUB_OUTPUT
            echo "remaining_resources=$remaining_in_state" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Terraform state is clean: no resources remaining"
            echo "verification_status=complete" >> $GITHUB_OUTPUT
            echo "remaining_resources=0" >> $GITHUB_OUTPUT
          fi

          # Additional validation using the validation script
          if [[ -x "./scripts/validate.sh" ]]; then
            echo "üîç Running additional resource validation..."
            if ./scripts/validate.sh --env=${{ github.event.inputs.environment }} --quick; then
              echo "‚ö†Ô∏è Warning: Some resources may still be accessible externally"
              echo "Please verify in Scaleway console for any orphaned resources"
            else
              echo "‚úÖ External validation: No accessible resources found"
            fi
          fi

      - name: Clean Up State Backend
        if: steps.verify.outputs.verification_status == 'complete'
        continue-on-error: true
        run: |
          echo "üßπ Cleaning up state backend for destroyed environment..."

          # Note: We don't delete the bucket itself as it may be used for other environments
          # But we could clean up the specific state file for this environment
          echo "State backend cleanup would be implemented here"
          echo "Bucket: ${{ needs.discover-backend-state.outputs.bucket_name }}"
          echo "State key: ${{ github.event.inputs.environment }}/terraform.tfstate"

          # For now, just log what we would clean up
          echo "‚úÖ State backend cleanup completed"

  post-teardown:
    name: Post-Teardown Actions
    runs-on: ubuntu-latest
    needs: [validate-request, discover-backend-state, prepare-teardown, analyze-impact, teardown]
    if: always() && needs.validate-request.outputs.confirmed == 'true'
    permissions:
      contents: read  # Read repository information
      actions: write  # Upload teardown report
      issues: write   # Create cleanup issues on failure

    steps:
      - name: Download Resource Inventory
        if: needs.prepare-teardown.result == 'success'
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: resource-inventory-${{ github.event.inputs.environment }}-${{ github.run_id }}
          path: ./reports/

      - name: Create Comprehensive Teardown Report
        id: report
        run: |
          # Determine verification status
          verification_status="${{ needs.teardown.outputs.verification_status || 'unknown' }}"
          remaining_resources="${{ needs.teardown.outputs.remaining_resources || 'unknown' }}"
          teardown_completed="${{ needs.teardown.outputs.teardown_completed || 'false' }}"

          cat > teardown-report.md << EOF
          # Comprehensive Teardown Report

          **Environment:** ${{ github.event.inputs.environment }}
          **Date:** $(date -Iseconds)
          **Triggered by:** ${{ github.actor }}
          **Workflow Status:** ${{ needs.teardown.result }}
          **Teardown Completed:** $teardown_completed
          **Verification Status:** $verification_status

          ## Pre-Teardown Analysis
          - **Backend Validation:** ${{ needs.discover-backend-state.result }}
          - **Resources Found:** ${{ needs.discover-backend-state.outputs.resource_count }}
          - **State Backend:** ${{ needs.discover-backend-state.outputs.bucket_name }}
          - **Preparation Status:** ${{ needs.prepare-teardown.result }}
          - **Drift Detected:** ${{ needs.prepare-teardown.outputs.drift_detected || 'N/A' }}
          - **Active Workspaces:** ${{ needs.analyze-impact.outputs.active_workspaces }}

          ## Teardown Configuration
          - **Emergency Mode:** ${{ github.event.inputs.emergency_mode }}
          - **Backup Created:** ${{ github.event.inputs.backup_before_destroy }}
          - **Data Preserved:** ${{ github.event.inputs.preserve_data }}
          - **Region:** ${{ github.event.inputs.region }}
          - **Zone:** ${{ github.event.inputs.availability_zone }}

          ## Results Summary
          EOF

          if [[ "$teardown_completed" == "true" && "$verification_status" == "complete" ]]; then
            cat >> teardown-report.md << EOF
          **‚úÖ TEARDOWN SUCCESSFUL**
          - All resources destroyed successfully
          - Terraform state is clean ($remaining_resources resources remaining)
          - Monthly cost savings: ‚Ç¨${{ needs.analyze-impact.outputs.cost_savings }}

          ### Next Steps
          - ‚úÖ Environment successfully torn down
          - Verify no unexpected charges in Scaleway console
          - Remove any manually created resources outside Terraform
          - Update DNS records if custom domain was used
          EOF

          elif [[ "$teardown_completed" == "false" || "$verification_status" == "incomplete" ]]; then
            cat >> teardown-report.md << EOF
          **‚ùå TEARDOWN INCOMPLETE**
          - Teardown failed or only partially completed
          - Resources remaining in state: $remaining_resources
          - Manual cleanup required to prevent ongoing costs

          ### Immediate Actions Required
          - üö® Check Scaleway console for remaining resources
          - üö® Manually delete any remaining infrastructure
          - üö® Verify billing to ensure no unexpected charges
          - üö® Consider re-running teardown workflow

          ### Resources That May Need Manual Cleanup
          - Cluster: \`coder-${{ github.event.inputs.environment }}\`
          - Database: \`coder-db-${{ github.event.inputs.environment }}\`
          - VPC: \`coder-vpc-${{ github.event.inputs.environment }}\`
          - Load Balancer: \`coder-lb-${{ github.event.inputs.environment }}\`
          EOF

          else
            cat >> teardown-report.md << EOF
          **‚ö†Ô∏è TEARDOWN STATUS UNCLEAR**
          - Teardown status could not be fully determined
          - Please verify manually in Scaleway console
          - Estimated monthly cost if not cleaned: ‚Ç¨${{ needs.analyze-impact.outputs.cost_savings }}
          EOF
          fi

          cat >> teardown-report.md << EOF

          ## Technical Details
          - **Workflow Run ID:** ${{ github.run_id }}
          - **Repository:** ${{ github.repository }}
          - **Commit SHA:** ${{ github.sha }}
          - **Backend State Bucket:** ${{ needs.discover-backend-state.outputs.bucket_name }}
          - **State Key:** ${{ github.event.inputs.environment }}/terraform.tfstate

          ## Workflow Job Results
          - **Validation:** ${{ needs.validate-request.result }}
          - **Backend State Check:** ${{ needs.discover-backend-state.result }}
          - **Preparation:** ${{ needs.prepare-teardown.result }}
          - **Impact Analysis:** ${{ needs.analyze-impact.result }}
          - **Teardown Execution:** ${{ needs.teardown.result }}

          ---
          *Report generated on $(date) by GitHub Actions*
          EOF

          echo "report_created=true" >> $GITHUB_OUTPUT

      - name: Upload Teardown Report
        uses: actions/upload-artifact@v4
        with:
          name: teardown-report-${{ github.event.inputs.environment }}-$(date +%Y%m%d)
          path: teardown-report.md
          retention-days: 90

      - name: Notify Teams
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [[ -n "$SLACK_WEBHOOK_URL" ]]; then
            status="${{ needs.teardown.result }}"
            environment="${{ github.event.inputs.environment }}"

            if [[ "$status" == "success" ]]; then
              color="good"
              emoji="üí•"
              text="Coder environment teardown completed"
            else
              color="danger"
              emoji="‚ö†Ô∏è"
              text="Coder environment teardown failed"
            fi

            payload="{
              \"attachments\": [{
                \"color\": \"$color\",
                \"text\": \"$emoji $text\",
                \"fields\": [
                  {\"title\": \"Environment\", \"value\": \"$environment\", \"short\": true},
                  {\"title\": \"Cost Savings\", \"value\": \"‚Ç¨${{ needs.analyze-impact.outputs.cost_savings }}/month\", \"short\": true},
                  {\"title\": \"Triggered by\", \"value\": \"${{ github.actor }}\", \"short\": true},
                  {\"title\": \"Repository\", \"value\": \"${{ github.repository }}\", \"short\": true}
                ]
              }]
            }"

            curl -X POST -H 'Content-type: application/json' \
              --data "$payload" "$SLACK_WEBHOOK_URL"
          else
            echo "Slack webhook not configured, skipping notification"
          fi

      - name: Create Cleanup Issue on Failure
        if: |
          needs.teardown.result == 'failure' ||
          (needs.teardown.outputs.teardown_completed == 'false') ||
          (needs.teardown.outputs.verification_status == 'incomplete')
        uses: actions/github-script@v7
        with:
          script: |
            const title = `Manual Cleanup Required: ${{ github.event.inputs.environment }} environment`;
            const teardownCompleted = '${{ needs.teardown.outputs.teardown_completed }}';
            const verificationStatus = '${{ needs.teardown.outputs.verification_status }}';
            const remainingResources = '${{ needs.teardown.outputs.remaining_resources }}';
            const backendValidation = '${{ needs.discover-backend-state.result }}';
            const resourcesFound = '${{ needs.discover-backend-state.outputs.resource_count }}';

            const body = `## Teardown Failure - Manual Cleanup Required

            **Environment:** ${{ github.event.inputs.environment }}
            **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            **Triggered by:** ${{ github.actor }}
            **Date:** ${new Date().toISOString()}

            ## Failure Analysis
            - **Backend Validation:** ${backendValidation}
            - **Resources Initially Found:** ${resourcesFound}
            - **Teardown Completed:** ${teardownCompleted}
            - **Verification Status:** ${verificationStatus}
            - **Resources Remaining:** ${remainingResources}

            The automated teardown has failed or completed incompletely. **Manual cleanup is required to prevent ongoing costs.**

            ## Immediate Actions Required
            1. **üö® Check Scaleway Console** - Log into console and verify remaining resources
            2. **üö® Manually delete** any remaining resources:
               - Kubernetes cluster: \`coder-${{ github.event.inputs.environment }}\`
               - Database: \`coder-db-${{ github.event.inputs.environment }}\`
               - Load balancer: \`coder-lb-${{ github.event.inputs.environment }}\`
               - VPC: \`coder-vpc-${{ github.event.inputs.environment }}\`
               - Storage volumes and snapshots
               - Container registries if any
            3. **üö® Verify billing** to ensure no unexpected charges are accumulating
            4. **üîÑ Consider re-running** the teardown workflow after manual cleanup

            ## State Backend Information
            - **Bucket:** ${{ needs.discover-backend-state.outputs.bucket_name }}
            - **State Key:** ${{ github.event.inputs.environment }}/terraform.tfstate
            - **Region:** ${{ github.event.inputs.region }}

            ## Recovery Options
            - **Option 1:** Manual cleanup through Scaleway console
            - **Option 2:** Fix issues and re-run teardown workflow
            - **Option 3:** Use Terraform CLI manually in environments/${{ github.event.inputs.environment }}

            ## Cost Impact
            **Estimated Monthly Cost if Not Cleaned:** ‚Ç¨${{ needs.analyze-impact.outputs.cost_savings }}

            ---
            **Priority:** üî¥ HIGH - Ongoing cost impact
            **Status:** Requires immediate manual intervention`;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['manual-cleanup-required', 'cost-impact', '${{ github.event.inputs.environment }}']
            });

      - name: Update Status
        if: always()
        run: |
          if [[ "${{ needs.teardown.result }}" == "success" ]]; then
            echo "‚úÖ Teardown completed successfully!"
            echo "Environment: ${{ github.event.inputs.environment }}"
            echo "Monthly cost savings: ‚Ç¨${{ needs.analyze-impact.outputs.cost_savings }}"
          else
            echo "‚ùå Teardown failed or incomplete!"
            echo "Manual cleanup may be required."
            echo "Check Scaleway console for remaining resources."
          fi